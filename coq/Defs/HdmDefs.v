(* generated by Ott 0.32, locally-nameless lngen from: /home/roger/hdm/ott/HdmDefs.ott *)
Require Import Metalib.Metatheory.
(** syntax *)
Definition index : Set := nat.
Definition termvar : Set := var. (*r term variable *)
Lemma eq_termvar: forall (x y : termvar), {x = y} + {x <> y}.
Proof.
apply eq_dec.
Defined.
#[export] Hint Resolve eq_termvar : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
Definition dskvar : Set := var. (*r Skolem variable *)
Lemma eq_dskvar: forall (x y : dskvar), {x = y} + {x <> y}.
Proof.
apply eq_dec.
Defined.
#[export] Hint Resolve eq_dskvar : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
Definition skvar : Set := var. (*r Skolem variable *)
Lemma eq_skvar: forall (x y : skvar), {x = y} + {x <> y}.
Proof.
apply eq_dec.
Defined.
#[export] Hint Resolve eq_skvar : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
Definition exvar : Set := atom. (*r existential variable *)
Lemma eq_exvar: forall (x y : exvar), {x = y} + {x <> y}.
Proof.
apply eq_dec.
Defined.
#[export] Hint Resolve eq_exvar : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)

Inductive DTy : Set :=  (*r Dec Types *)
 | DT_SkVar_b (_:nat) (*r Skolem variable *)
 | DT_SkVar_f (dskA:dskvar) (*r Skolem variable *)
 | DT_Unit : DTy (*r Unit type *)
 | DT_Fun (DTy1:DTy) (DTy2:DTy) (*r Function type *).

Inductive Ty : Set :=  (*r Types *)
 | T_SkVar_b (_:nat) (*r Skolem variable *)
 | T_SkVar_f (skA:skvar) (*r Skolem variable *)
 | T_ExVar (exA:exvar) (*r Existential variable *)
 | T_Unit : Ty (*r Unit type *)
 | T_Fun (Ty1:Ty) (Ty2:Ty) (*r Function type *).

Definition DA : Set := list dskvar.

Inductive DSch : Set :=  (*r Dec Type schemes *)
 | DS_Mono (DTy5:DTy) (*r Monotype *)
 | DS_Forall (DSch5:DSch) (*r Forall *).

Definition A : Set := list exvar.

Inductive Sch : Set :=  (*r Type schemes *)
 | S_Mono (Ty5:Ty) (*r Monotype *)
 | S_Forall (Sch5:Sch) (*r Forall *).

Inductive DObj : Set :=  (*r Objects *)
 | DObj_DSch (DA5:DA) (DSch5:DSch) (*r Scheme *).

Inductive Obj : Set :=  (*r Objects *)
 | Obj_Sch (A5:A) (Sch5:Sch) (*r Scheme *).

Inductive e : Set :=  (*r Terms *)
 | e_Var_b (_:nat) (*r Term variable *)
 | e_Var_f (x:termvar) (*r Term variable *)
 | e_Unit : e (*r Term unit *)
 | e_App (e1:e) (e2:e) (*r Application *)
 | e_Lam (e5:e) (*r Abstraction *)
 | e_Let (e1:e) (e2:e) (*r Let binding *).

Inductive DEnv : Set :=  (*r Dec Environment *)
 | DEnv_Empty : DEnv (*r Empty environment *)
 | DEnv_DSkol (DEnv5:DEnv) (dskA:dskvar) (*r Cons Sk *)
 | DEnv_DVar (DEnv5:DEnv) (x:termvar) (DSch5:DSch) (*r Cons Variable *)
 | DEnv_DObj (DEnv5:DEnv) (DObj5:DObj) (*r Cons Object *).

Inductive Env : Set :=  (*r Environment *)
 | Env_Empty : Env (*r Empty environment *)
 | Env_Skol (Env5:Env) (skA:skvar) (*r Cons Skolem variable *)
 | Env_A (Env5:Env) (A5:A) (*r Cons Existential environment *)
 | Env_Var (Env5:Env) (x:termvar) (Sch5:Sch) (*r Cons Variable *)
 | Env_Obj (Env5:Env) (Obj5:Obj) (*r Cons Object *).

Definition DSub : Set := list (exvar * DTy).

Definition Sub : Set := list (exvar * Ty).

Definition Eqs : Set := list (Ty * Ty).
Lemma eq_DTy: forall (x y : DTy), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_DTy : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
Lemma eq_Ty: forall (x y : Ty), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_Ty : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
Lemma eq_DSch: forall (x y : DSch), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_DSch : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
Lemma eq_Sch: forall (x y : Sch), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_Sch : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
Lemma eq_e: forall (x y : e), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_e : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_Ty_wrt_Ty_rec (k:nat) (Ty_6:Ty) (Ty__7:Ty) {struct Ty__7}: Ty :=
  match Ty__7 with
  | (T_SkVar_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => T_SkVar_b nat
        | inleft (right _) => Ty_6
        | inright _ => T_SkVar_b (nat - 1)
      end
  | (T_SkVar_f skA) => T_SkVar_f skA
  | (T_ExVar exA) => T_ExVar exA
  | T_Unit => T_Unit 
  | (T_Fun Ty1 Ty2) => T_Fun (open_Ty_wrt_Ty_rec k Ty_6 Ty1) (open_Ty_wrt_Ty_rec k Ty_6 Ty2)
end.

Fixpoint open_DTy_wrt_DTy_rec (k:nat) (DTy_6:DTy) (DTy__7:DTy) {struct DTy__7}: DTy :=
  match DTy__7 with
  | (DT_SkVar_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => DT_SkVar_b nat
        | inleft (right _) => DTy_6
        | inright _ => DT_SkVar_b (nat - 1)
      end
  | (DT_SkVar_f dskA) => DT_SkVar_f dskA
  | DT_Unit => DT_Unit 
  | (DT_Fun DTy1 DTy2) => DT_Fun (open_DTy_wrt_DTy_rec k DTy_6 DTy1) (open_DTy_wrt_DTy_rec k DTy_6 DTy2)
end.

Fixpoint open_Sch_wrt_Ty_rec (k:nat) (Ty_6:Ty) (Sch_6:Sch) {struct Sch_6}: Sch :=
  match Sch_6 with
  | (S_Mono Ty5) => S_Mono (open_Ty_wrt_Ty_rec k Ty_6 Ty5)
  | (S_Forall Sch5) => S_Forall (open_Sch_wrt_Ty_rec (S k) Ty_6 Sch5)
end.

Fixpoint open_DSch_wrt_DTy_rec (k:nat) (DTy_6:DTy) (DSch_6:DSch) {struct DSch_6}: DSch :=
  match DSch_6 with
  | (DS_Mono DTy5) => DS_Mono (open_DTy_wrt_DTy_rec k DTy_6 DTy5)
  | (DS_Forall DSch5) => DS_Forall (open_DSch_wrt_DTy_rec (S k) DTy_6 DSch5)
end.

Definition open_Obj_wrt_Ty_rec (k:nat) (Ty5:Ty) (Obj5:Obj) : Obj :=
  match Obj5 with
  | (Obj_Sch A5 Sch5) => Obj_Sch A5 (open_Sch_wrt_Ty_rec k Ty5 Sch5)
end.

Definition open_DObj_wrt_DTy_rec (k:nat) (DTy5:DTy) (DObj5:DObj) : DObj :=
  match DObj5 with
  | (DObj_DSch DA5 DSch5) => DObj_DSch DA5 (open_DSch_wrt_DTy_rec k DTy5 DSch5)
end.

Fixpoint open_Env_wrt_Ty_rec (k:nat) (Ty_6:Ty) (Env_6:Env) {struct Env_6}: Env :=
  match Env_6 with
  | Env_Empty => Env_Empty 
  | (Env_Skol Env5 skA) => Env_Skol (open_Env_wrt_Ty_rec k Ty_6 Env5) skA
  | (Env_A Env5 A5) => Env_A (open_Env_wrt_Ty_rec k Ty_6 Env5) A5
  | (Env_Var Env5 x Sch5) => Env_Var (open_Env_wrt_Ty_rec k Ty_6 Env5) x (open_Sch_wrt_Ty_rec k Ty_6 Sch5)
  | (Env_Obj Env5 Obj5) => Env_Obj (open_Env_wrt_Ty_rec k Ty_6 Env5) (open_Obj_wrt_Ty_rec k Ty_6 Obj5)
end.

Fixpoint open_DEnv_wrt_DTy_rec (k:nat) (DTy5:DTy) (DEnv_6:DEnv) {struct DEnv_6}: DEnv :=
  match DEnv_6 with
  | DEnv_Empty => DEnv_Empty 
  | (DEnv_DSkol DEnv5 dskA) => DEnv_DSkol (open_DEnv_wrt_DTy_rec k DTy5 DEnv5) dskA
  | (DEnv_DVar DEnv5 x DSch5) => DEnv_DVar (open_DEnv_wrt_DTy_rec k DTy5 DEnv5) x (open_DSch_wrt_DTy_rec k DTy5 DSch5)
  | (DEnv_DObj DEnv5 DObj5) => DEnv_DObj (open_DEnv_wrt_DTy_rec k DTy5 DEnv5) (open_DObj_wrt_DTy_rec k DTy5 DObj5)
end.

Fixpoint open_e_wrt_e_rec (k:nat) (e_6:e) (e__7:e) {struct e__7}: e :=
  match e__7 with
  | (e_Var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => e_Var_b nat
        | inleft (right _) => e_6
        | inright _ => e_Var_b (nat - 1)
      end
  | (e_Var_f x) => e_Var_f x
  | e_Unit => e_Unit 
  | (e_App e1 e2) => e_App (open_e_wrt_e_rec k e_6 e1) (open_e_wrt_e_rec k e_6 e2)
  | (e_Lam e5) => e_Lam (open_e_wrt_e_rec (S k) e_6 e5)
  | (e_Let e1 e2) => e_Let (open_e_wrt_e_rec k e_6 e1) (open_e_wrt_e_rec (S k) e_6 e2)
end.

Definition open_Ty_wrt_Ty Ty_6 Ty__7 := open_Ty_wrt_Ty_rec 0 Ty__7 Ty_6.

Definition open_DSch_wrt_DTy DTy_6 DSch_6 := open_DSch_wrt_DTy_rec 0 DSch_6 DTy_6.

Definition open_Env_wrt_Ty Ty_6 Env_6 := open_Env_wrt_Ty_rec 0 Env_6 Ty_6.

Definition open_DEnv_wrt_DTy DTy5 DEnv_6 := open_DEnv_wrt_DTy_rec 0 DEnv_6 DTy5.

Definition open_Sch_wrt_Ty Ty_6 Sch_6 := open_Sch_wrt_Ty_rec 0 Sch_6 Ty_6.

Definition open_DObj_wrt_DTy DTy5 DObj5 := open_DObj_wrt_DTy_rec 0 DObj5 DTy5.

Definition open_DTy_wrt_DTy DTy_6 DTy__7 := open_DTy_wrt_DTy_rec 0 DTy__7 DTy_6.

Definition open_e_wrt_e e_6 e__7 := open_e_wrt_e_rec 0 e__7 e_6.

Definition open_Obj_wrt_Ty Ty5 Obj5 := open_Obj_wrt_Ty_rec 0 Obj5 Ty5.

(** closing up abstractions *)
Fixpoint close_Ty_wrt_Ty_rec (k:nat) (Ty_6:var) (Ty__7:Ty) {struct Ty__7}: Ty :=
  match Ty__7 with
  | (T_SkVar_b nat) => 
       if (lt_dec nat k) 
         then T_SkVar_b nat
         else T_SkVar_b (S nat)
  | (T_SkVar_f skA) => if (Ty_6 === skA) then (T_SkVar_b k) else (T_SkVar_f skA)
  | (T_ExVar exA) => T_ExVar exA
  | T_Unit => T_Unit 
  | (T_Fun Ty1 Ty2) => T_Fun (close_Ty_wrt_Ty_rec k Ty_6 Ty1) (close_Ty_wrt_Ty_rec k Ty_6 Ty2)
end.

Fixpoint close_DTy_wrt_DTy_rec (k:nat) (DTy_6:var) (DTy__7:DTy) {struct DTy__7}: DTy :=
  match DTy__7 with
  | (DT_SkVar_b nat) => 
       if (lt_dec nat k) 
         then DT_SkVar_b nat
         else DT_SkVar_b (S nat)
  | (DT_SkVar_f dskA) => if (DTy_6 === dskA) then (DT_SkVar_b k) else (DT_SkVar_f dskA)
  | DT_Unit => DT_Unit 
  | (DT_Fun DTy1 DTy2) => DT_Fun (close_DTy_wrt_DTy_rec k DTy_6 DTy1) (close_DTy_wrt_DTy_rec k DTy_6 DTy2)
end.

Fixpoint close_Sch_wrt_Ty_rec (k:nat) (Ty_6:var) (Sch_6:Sch) {struct Sch_6}: Sch :=
  match Sch_6 with
  | (S_Mono Ty5) => S_Mono (close_Ty_wrt_Ty_rec k Ty_6 Ty5)
  | (S_Forall Sch5) => S_Forall (close_Sch_wrt_Ty_rec (S k) Ty_6 Sch5)
end.

Fixpoint close_DSch_wrt_DTy_rec (k:nat) (DTy_6:var) (DSch_6:DSch) {struct DSch_6}: DSch :=
  match DSch_6 with
  | (DS_Mono DTy5) => DS_Mono (close_DTy_wrt_DTy_rec k DTy_6 DTy5)
  | (DS_Forall DSch5) => DS_Forall (close_DSch_wrt_DTy_rec (S k) DTy_6 DSch5)
end.

Definition close_Obj_wrt_Ty_rec (k:nat) (Ty5:var) (Obj5:Obj) : Obj :=
  match Obj5 with
  | (Obj_Sch A5 Sch5) => Obj_Sch A5 (close_Sch_wrt_Ty_rec k Ty5 Sch5)
end.

Definition close_DObj_wrt_DTy_rec (k:nat) (DTy5:var) (DObj5:DObj) : DObj :=
  match DObj5 with
  | (DObj_DSch DA5 DSch5) => DObj_DSch DA5 (close_DSch_wrt_DTy_rec k DTy5 DSch5)
end.

Fixpoint close_Env_wrt_Ty_rec (k:nat) (Ty_6:var) (Env_6:Env) {struct Env_6}: Env :=
  match Env_6 with
  | Env_Empty => Env_Empty 
  | (Env_Skol Env5 skA) => Env_Skol (close_Env_wrt_Ty_rec k Ty_6 Env5) skA
  | (Env_A Env5 A5) => Env_A (close_Env_wrt_Ty_rec k Ty_6 Env5) A5
  | (Env_Var Env5 x Sch5) => Env_Var (close_Env_wrt_Ty_rec k Ty_6 Env5) x (close_Sch_wrt_Ty_rec k Ty_6 Sch5)
  | (Env_Obj Env5 Obj5) => Env_Obj (close_Env_wrt_Ty_rec k Ty_6 Env5) (close_Obj_wrt_Ty_rec k Ty_6 Obj5)
end.

Fixpoint close_DEnv_wrt_DTy_rec (k:nat) (DTy5:var) (DEnv_6:DEnv) {struct DEnv_6}: DEnv :=
  match DEnv_6 with
  | DEnv_Empty => DEnv_Empty 
  | (DEnv_DSkol DEnv5 dskA) => DEnv_DSkol (close_DEnv_wrt_DTy_rec k DTy5 DEnv5) dskA
  | (DEnv_DVar DEnv5 x DSch5) => DEnv_DVar (close_DEnv_wrt_DTy_rec k DTy5 DEnv5) x (close_DSch_wrt_DTy_rec k DTy5 DSch5)
  | (DEnv_DObj DEnv5 DObj5) => DEnv_DObj (close_DEnv_wrt_DTy_rec k DTy5 DEnv5) (close_DObj_wrt_DTy_rec k DTy5 DObj5)
end.

Fixpoint close_e_wrt_e_rec (k:nat) (e_6:var) (e__7:e) {struct e__7}: e :=
  match e__7 with
  | (e_Var_b nat) => 
       if (lt_dec nat k) 
         then e_Var_b nat
         else e_Var_b (S nat)
  | (e_Var_f x) => if (e_6 === x) then (e_Var_b k) else (e_Var_f x)
  | e_Unit => e_Unit 
  | (e_App e1 e2) => e_App (close_e_wrt_e_rec k e_6 e1) (close_e_wrt_e_rec k e_6 e2)
  | (e_Lam e5) => e_Lam (close_e_wrt_e_rec (S k) e_6 e5)
  | (e_Let e1 e2) => e_Let (close_e_wrt_e_rec k e_6 e1) (close_e_wrt_e_rec (S k) e_6 e2)
end.

Definition close_DSch_wrt_DTy DSch_6 DTy_6 := close_DSch_wrt_DTy_rec 0 DSch_6 DTy_6.

Definition close_Env_wrt_Ty Env_6 Ty_6 := close_Env_wrt_Ty_rec 0 Env_6 Ty_6.

Definition close_DEnv_wrt_DTy DEnv_6 DTy5 := close_DEnv_wrt_DTy_rec 0 DEnv_6 DTy5.

Definition close_Sch_wrt_Ty Sch_6 Ty_6 := close_Sch_wrt_Ty_rec 0 Sch_6 Ty_6.

Definition close_DObj_wrt_DTy DObj5 DTy5 := close_DObj_wrt_DTy_rec 0 DObj5 DTy5.

Definition close_DTy_wrt_DTy DTy__7 DTy_6 := close_DTy_wrt_DTy_rec 0 DTy__7 DTy_6.

Definition close_e_wrt_e e__7 e_6 := close_e_wrt_e_rec 0 e__7 e_6.

Definition close_Obj_wrt_Ty Obj5 Ty5 := close_Obj_wrt_Ty_rec 0 Obj5 Ty5.

Definition close_Ty_wrt_Ty Ty__7 Ty_6 := close_Ty_wrt_Ty_rec 0 Ty__7 Ty_6.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_DTy *)
Inductive lc_DTy : DTy -> Prop :=    (* defn lc_DTy *)
 | lc_DT_SkVar_f : forall (dskA:dskvar),
     (lc_DTy (DT_SkVar_f dskA))
 | lc_DT_Unit : 
     (lc_DTy DT_Unit)
 | lc_DT_Fun : forall (DTy1 DTy2:DTy),
     (lc_DTy DTy1) ->
     (lc_DTy DTy2) ->
     (lc_DTy (DT_Fun DTy1 DTy2)).

(* defns LC_Ty *)
Inductive lc_Ty : Ty -> Prop :=    (* defn lc_Ty *)
 | lc_T_SkVar_f : forall (skA:skvar),
     (lc_Ty (T_SkVar_f skA))
 | lc_T_ExVar : forall (exA:exvar),
     (lc_Ty (T_ExVar exA))
 | lc_T_Unit : 
     (lc_Ty T_Unit)
 | lc_T_Fun : forall (Ty1 Ty2:Ty),
     (lc_Ty Ty1) ->
     (lc_Ty Ty2) ->
     (lc_Ty (T_Fun Ty1 Ty2)).

(* defns LC_DSch *)
Inductive lc_DSch : DSch -> Prop :=    (* defn lc_DSch *)
 | lc_DS_Mono : forall (DTy5:DTy),
     (lc_DTy DTy5) ->
     (lc_DSch (DS_Mono DTy5))
 | lc_DS_Forall : forall (DSch5:DSch),
      ( forall dskA , lc_DSch  ( open_DSch_wrt_DTy DSch5 (DT_SkVar_f dskA) )  )  ->
     (lc_DSch (DS_Forall DSch5)).

(* defns LC_Sch *)
Inductive lc_Sch : Sch -> Prop :=    (* defn lc_Sch *)
 | lc_S_Mono : forall (Ty5:Ty),
     (lc_Ty Ty5) ->
     (lc_Sch (S_Mono Ty5))
 | lc_S_Forall : forall (Sch5:Sch),
      ( forall skA , lc_Sch  ( open_Sch_wrt_Ty Sch5 (T_SkVar_f skA) )  )  ->
     (lc_Sch (S_Forall Sch5)).

(* defns LC_DObj *)
Inductive lc_DObj : DObj -> Prop :=    (* defn lc_DObj *)
 | lc_DObj_DSch : forall (DA5:DA) (DSch5:DSch),
     (lc_DSch DSch5) ->
     (lc_DObj (DObj_DSch DA5 DSch5)).

(* defns LC_Obj *)
Inductive lc_Obj : Obj -> Prop :=    (* defn lc_Obj *)
 | lc_Obj_Sch : forall (A5:A) (Sch5:Sch),
     (lc_Sch Sch5) ->
     (lc_Obj (Obj_Sch A5 Sch5)).

(* defns LC_e *)
Inductive lc_e : e -> Prop :=    (* defn lc_e *)
 | lc_e_Var_f : forall (x:termvar),
     (lc_e (e_Var_f x))
 | lc_e_Unit : 
     (lc_e e_Unit)
 | lc_e_App : forall (e1 e2:e),
     (lc_e e1) ->
     (lc_e e2) ->
     (lc_e (e_App e1 e2))
 | lc_e_Lam : forall (e5:e),
      ( forall x , lc_e  ( open_e_wrt_e e5 (e_Var_f x) )  )  ->
     (lc_e (e_Lam e5))
 | lc_e_Let : forall (e1 e2:e),
     (lc_e e1) ->
      ( forall x , lc_e  ( open_e_wrt_e e2 (e_Var_f x) )  )  ->
     (lc_e (e_Let e1 e2)).

(* defns LC_DEnv *)
Inductive lc_DEnv : DEnv -> Prop :=    (* defn lc_DEnv *)
 | lc_DEnv_Empty : 
     (lc_DEnv DEnv_Empty)
 | lc_DEnv_DSkol : forall (DEnv5:DEnv) (dskA:dskvar),
     (lc_DEnv DEnv5) ->
     (lc_DEnv (DEnv_DSkol DEnv5 dskA))
 | lc_DEnv_DVar : forall (DEnv5:DEnv) (x:termvar) (DSch5:DSch),
     (lc_DEnv DEnv5) ->
     (lc_DSch DSch5) ->
     (lc_DEnv (DEnv_DVar DEnv5 x DSch5))
 | lc_DEnv_DObj : forall (DEnv5:DEnv) (DObj5:DObj),
     (lc_DEnv DEnv5) ->
     (lc_DObj DObj5) ->
     (lc_DEnv (DEnv_DObj DEnv5 DObj5)).

(* defns LC_Env *)
Inductive lc_Env : Env -> Prop :=    (* defn lc_Env *)
 | lc_Env_Empty : 
     (lc_Env Env_Empty)
 | lc_Env_Skol : forall (Env5:Env) (skA:skvar),
     (lc_Env Env5) ->
     (lc_Env (Env_Skol Env5 skA))
 | lc_Env_A : forall (Env5:Env) (A5:A),
     (lc_Env Env5) ->
     (lc_Env (Env_A Env5 A5))
 | lc_Env_Var : forall (Env5:Env) (x:termvar) (Sch5:Sch),
     (lc_Env Env5) ->
     (lc_Sch Sch5) ->
     (lc_Env (Env_Var Env5 x Sch5))
 | lc_Env_Obj : forall (Env5:Env) (Obj5:Obj),
     (lc_Env Env5) ->
     (lc_Obj Obj5) ->
     (lc_Env (Env_Obj Env5 Obj5)).
(** free variables *)
Fixpoint free_skvars_Ty (Ty_6:Ty) : vars :=
  match Ty_6 with
  | (T_SkVar_b nat) => {}
  | (T_SkVar_f skA) => {{skA}}
  | (T_ExVar exA) => {}
  | T_Unit => {}
  | (T_Fun Ty1 Ty2) => (free_skvars_Ty Ty1) \u (free_skvars_Ty Ty2)
end.

Fixpoint free_exvars_Ty (Ty_6:Ty) : vars :=
  match Ty_6 with
  | (T_SkVar_b nat) => {}
  | (T_SkVar_f skA) => {}
  | (T_ExVar exA) => {{exA}}
  | T_Unit => {}
  | (T_Fun Ty1 Ty2) => (free_exvars_Ty Ty1) \u (free_exvars_Ty Ty2)
end.

Fixpoint free_dskvars_DTy (DTy_6:DTy) : vars :=
  match DTy_6 with
  | (DT_SkVar_b nat) => {}
  | (DT_SkVar_f dskA) => {{dskA}}
  | DT_Unit => {}
  | (DT_Fun DTy1 DTy2) => (free_dskvars_DTy DTy1) \u (free_dskvars_DTy DTy2)
end.

Fixpoint free_skvars_Sch (Sch_6:Sch) : vars :=
  match Sch_6 with
  | (S_Mono Ty5) => (free_skvars_Ty Ty5)
  | (S_Forall Sch5) => (free_skvars_Sch Sch5)
end.

Fixpoint free_exvars_Sch (Sch_6:Sch) : vars :=
  match Sch_6 with
  | (S_Mono Ty5) => (free_exvars_Ty Ty5)
  | (S_Forall Sch5) => (free_exvars_Sch Sch5)
end.

Fixpoint free_dskvars_DSch (DSch_6:DSch) : vars :=
  match DSch_6 with
  | (DS_Mono DTy5) => (free_dskvars_DTy DTy5)
  | (DS_Forall DSch5) => (free_dskvars_DSch DSch5)
end.

Definition free_skvars_Obj (Obj5:Obj) : vars :=
  match Obj5 with
  | (Obj_Sch A5 Sch5) => (free_skvars_Sch Sch5)
end.

Definition free_exvars_Obj (Obj5:Obj) : vars :=
  match Obj5 with
  | (Obj_Sch A5 Sch5) => (free_exvars_Sch Sch5)
end.

Definition free_dskvars_DObj (DObj5:DObj) : vars :=
  match DObj5 with
  | (DObj_DSch DA5 DSch5) => (free_dskvars_DSch DSch5)
end.

Fixpoint free_xs_e (e_6:e) : vars :=
  match e_6 with
  | (e_Var_b nat) => {}
  | (e_Var_f x) => {{x}}
  | e_Unit => {}
  | (e_App e1 e2) => (free_xs_e e1) \u (free_xs_e e2)
  | (e_Lam e5) => (free_xs_e e5)
  | (e_Let e1 e2) => (free_xs_e e1) \u (free_xs_e e2)
end.

Fixpoint free_skvars_Env (Env_6:Env) : vars :=
  match Env_6 with
  | Env_Empty => {}
  | (Env_Skol Env5 skA) => (free_skvars_Env Env5)
  | (Env_A Env5 A5) => (free_skvars_Env Env5)
  | (Env_Var Env5 x Sch5) => (free_skvars_Env Env5) \u (free_skvars_Sch Sch5)
  | (Env_Obj Env5 Obj5) => (free_skvars_Env Env5) \u (free_skvars_Obj Obj5)
end.

Fixpoint free_exvars_Env (Env_6:Env) : vars :=
  match Env_6 with
  | Env_Empty => {}
  | (Env_Skol Env5 skA) => (free_exvars_Env Env5)
  | (Env_A Env5 A5) => (free_exvars_Env Env5)
  | (Env_Var Env5 x Sch5) => (free_exvars_Env Env5) \u (free_exvars_Sch Sch5)
  | (Env_Obj Env5 Obj5) => (free_exvars_Env Env5) \u (free_exvars_Obj Obj5)
end.

Fixpoint free_dskvars_DEnv (DEnv_6:DEnv) : vars :=
  match DEnv_6 with
  | DEnv_Empty => {}
  | (DEnv_DSkol DEnv5 dskA) => (free_dskvars_DEnv DEnv5)
  | (DEnv_DVar DEnv5 x DSch5) => (free_dskvars_DEnv DEnv5) \u (free_dskvars_DSch DSch5)
  | (DEnv_DObj DEnv5 DObj5) => (free_dskvars_DEnv DEnv5) \u (free_dskvars_DObj DObj5)
end.

(** substitutions *)
Fixpoint subst_exvar_Ty (Ty_6:Ty) (exA5:exvar) (Ty__7:Ty) {struct Ty__7} : Ty :=
  match Ty__7 with
  | (T_SkVar_b nat) => T_SkVar_b nat
  | (T_SkVar_f skA) => T_SkVar_f skA
  | (T_ExVar exA) => (if eq_var exA exA5 then Ty_6 else (T_ExVar exA))
  | T_Unit => T_Unit 
  | (T_Fun Ty1 Ty2) => T_Fun (subst_exvar_Ty Ty_6 exA5 Ty1) (subst_exvar_Ty Ty_6 exA5 Ty2)
end.

Fixpoint subst_skvar_Ty (Ty_6:Ty) (skA5:skvar) (Ty__7:Ty) {struct Ty__7} : Ty :=
  match Ty__7 with
  | (T_SkVar_b nat) => T_SkVar_b nat
  | (T_SkVar_f skA) => (if eq_var skA skA5 then Ty_6 else (T_SkVar_f skA))
  | (T_ExVar exA) => T_ExVar exA
  | T_Unit => T_Unit 
  | (T_Fun Ty1 Ty2) => T_Fun (subst_skvar_Ty Ty_6 skA5 Ty1) (subst_skvar_Ty Ty_6 skA5 Ty2)
end.

Fixpoint subst_dskvar_DTy (DTy_6:DTy) (dskA5:dskvar) (DTy__7:DTy) {struct DTy__7} : DTy :=
  match DTy__7 with
  | (DT_SkVar_b nat) => DT_SkVar_b nat
  | (DT_SkVar_f dskA) => (if eq_var dskA dskA5 then DTy_6 else (DT_SkVar_f dskA))
  | DT_Unit => DT_Unit 
  | (DT_Fun DTy1 DTy2) => DT_Fun (subst_dskvar_DTy DTy_6 dskA5 DTy1) (subst_dskvar_DTy DTy_6 dskA5 DTy2)
end.

Fixpoint subst_exvar_Sch (Ty_6:Ty) (exA5:exvar) (Sch_6:Sch) {struct Sch_6} : Sch :=
  match Sch_6 with
  | (S_Mono Ty5) => S_Mono (subst_exvar_Ty Ty_6 exA5 Ty5)
  | (S_Forall Sch5) => S_Forall (subst_exvar_Sch Ty_6 exA5 Sch5)
end.

Fixpoint subst_skvar_Sch (Ty_6:Ty) (skA5:skvar) (Sch_6:Sch) {struct Sch_6} : Sch :=
  match Sch_6 with
  | (S_Mono Ty5) => S_Mono (subst_skvar_Ty Ty_6 skA5 Ty5)
  | (S_Forall Sch5) => S_Forall (subst_skvar_Sch Ty_6 skA5 Sch5)
end.

Fixpoint subst_dskvar_DSch (DTy_6:DTy) (dskA5:dskvar) (DSch_6:DSch) {struct DSch_6} : DSch :=
  match DSch_6 with
  | (DS_Mono DTy5) => DS_Mono (subst_dskvar_DTy DTy_6 dskA5 DTy5)
  | (DS_Forall DSch5) => DS_Forall (subst_dskvar_DSch DTy_6 dskA5 DSch5)
end.

Definition subst_exvar_Obj (Ty5:Ty) (exA5:exvar) (Obj5:Obj) : Obj :=
  match Obj5 with
  | (Obj_Sch A5 Sch5) => Obj_Sch A5 (subst_exvar_Sch Ty5 exA5 Sch5)
end.

Definition subst_skvar_Obj (Ty5:Ty) (skA5:skvar) (Obj5:Obj) : Obj :=
  match Obj5 with
  | (Obj_Sch A5 Sch5) => Obj_Sch A5 (subst_skvar_Sch Ty5 skA5 Sch5)
end.

Definition subst_dskvar_DObj (DTy5:DTy) (dskA5:dskvar) (DObj5:DObj) : DObj :=
  match DObj5 with
  | (DObj_DSch DA5 DSch5) => DObj_DSch DA5 (subst_dskvar_DSch DTy5 dskA5 DSch5)
end.

Fixpoint subst_tm_e (e_6:e) (x5:termvar) (e__7:e) {struct e__7} : e :=
  match e__7 with
  | (e_Var_b nat) => e_Var_b nat
  | (e_Var_f x) => (if eq_var x x5 then e_6 else (e_Var_f x))
  | e_Unit => e_Unit 
  | (e_App e1 e2) => e_App (subst_tm_e e_6 x5 e1) (subst_tm_e e_6 x5 e2)
  | (e_Lam e5) => e_Lam (subst_tm_e e_6 x5 e5)
  | (e_Let e1 e2) => e_Let (subst_tm_e e_6 x5 e1) (subst_tm_e e_6 x5 e2)
end.

Fixpoint subst_exvar_Env (Ty_6:Ty) (exA5:exvar) (Env_6:Env) {struct Env_6} : Env :=
  match Env_6 with
  | Env_Empty => Env_Empty 
  | (Env_Skol Env5 skA) => Env_Skol (subst_exvar_Env Ty_6 exA5 Env5) skA
  | (Env_A Env5 A5) => Env_A (subst_exvar_Env Ty_6 exA5 Env5) A5
  | (Env_Var Env5 x Sch5) => Env_Var (subst_exvar_Env Ty_6 exA5 Env5) x (subst_exvar_Sch Ty_6 exA5 Sch5)
  | (Env_Obj Env5 Obj5) => Env_Obj (subst_exvar_Env Ty_6 exA5 Env5) (subst_exvar_Obj Ty_6 exA5 Obj5)
end.

Fixpoint subst_skvar_Env (Ty_6:Ty) (skA5:skvar) (Env_6:Env) {struct Env_6} : Env :=
  match Env_6 with
  | Env_Empty => Env_Empty 
  | (Env_Skol Env5 skA) => Env_Skol (subst_skvar_Env Ty_6 skA5 Env5) skA
  | (Env_A Env5 A5) => Env_A (subst_skvar_Env Ty_6 skA5 Env5) A5
  | (Env_Var Env5 x Sch5) => Env_Var (subst_skvar_Env Ty_6 skA5 Env5) x (subst_skvar_Sch Ty_6 skA5 Sch5)
  | (Env_Obj Env5 Obj5) => Env_Obj (subst_skvar_Env Ty_6 skA5 Env5) (subst_skvar_Obj Ty_6 skA5 Obj5)
end.

Fixpoint subst_dskvar_DEnv (DTy5:DTy) (dskA5:dskvar) (DEnv_6:DEnv) {struct DEnv_6} : DEnv :=
  match DEnv_6 with
  | DEnv_Empty => DEnv_Empty 
  | (DEnv_DSkol DEnv5 dskA) => DEnv_DSkol (subst_dskvar_DEnv DTy5 dskA5 DEnv5) dskA
  | (DEnv_DVar DEnv5 x DSch5) => DEnv_DVar (subst_dskvar_DEnv DTy5 dskA5 DEnv5) x (subst_dskvar_DSch DTy5 dskA5 DSch5)
  | (DEnv_DObj DEnv5 DObj5) => DEnv_DObj (subst_dskvar_DEnv DTy5 dskA5 DEnv5) (subst_dskvar_DObj DTy5 dskA5 DObj5)
end.

(*Require Import TLC.LibTactics.*)
Require Import LibTactics.LibTactics.
Require Import Coq.micromega.Lia.
Require Export Metalib.LibLNgen.
Require Import Coq.Program.Equality.
Require Import Metalib.MetatheoryAtom.
Require Import Cpdtlib.CpdtTactics.

Require Import Defs.HdmRewrites.

From Coq Require Import Init.Logic.

#[export] Hint Constructors Compare : core.
Set Warnings "-notation-overridden".

Open Scope program_scope.

(*
with DGen : DEnv -> e -> DSch -> Prop :=    (* defn DGen *)
 | DGenGen : forall (L:vars) (DEnv5:DEnv) (e5:e) (DSch5:DSch) (DTy5:DTy)
     (MON: (forall da, AtomSetImpl.disjoint (varl da) L
                -> Mon ( DEnv_DA  DEnv5   da  )  e5 DTy5
                /\ generalize_DSch  (DS_Mono DTy5)   da  =  DSch5)),
     DGen DEnv5 e5 DSch5
*)

Definition DEnv_DA : DEnv -> list dskvar -> DEnv := fold_right (flip DEnv_DSkol).

Definition oneDS dskA   : DEnv := DEnv_DSkol DEnv_Empty dskA.
Definition oneDA DA     : DEnv := DEnv_DA    DEnv_Empty DA.
Definition oneDX x dsch : DEnv := DEnv_DVar  DEnv_Empty x dsch.
Definition oneDO dobj   : DEnv := DEnv_DObj  DEnv_Empty dobj.

Definition oneS skA   : Env := Env_Skol Env_Empty skA.
Definition oneA A     : Env := Env_A    Env_Empty A.
Definition oneX x sch : Env := Env_Var  Env_Empty x sch.
Definition oneO obj   : Env := Env_Obj   Env_Empty obj.

(*** Interface *)
Class SetProps (A : Type) :=
(* If you extend this, remember to extend rewr_setprops*)
  { SEqual     : A -> A -> Prop
  ; SSubset    : A -> A -> Prop
  ; Sunion     : A -> A -> A
  ; Sempty     : A
  ; Selt       : Type
  ; Ssingleton : Selt -> A
  ; SIn        : Selt -> A -> Prop
  }.

#[export] Hint Extern 1 (SEqual     _ _) => simpl SEqual     : core.
#[export] Hint Extern 1 (SSubset    _ _) => simpl SSubset    : core.
#[export] Hint Extern 1 (Sunion     _ _) => simpl Sunion     : core.
#[export] Hint Extern 1 (Sempty        ) => simpl Sempty     : core.
#[export] Hint Extern 1 (Selt          ) => simpl Selt       : core.
#[export] Hint Extern 1 (Ssingleton _  ) => simpl Ssingleton : core.
#[export] Hint Extern 1 (SIn        _ _) => simpl SIn        : core.

(*** Declarative *)
(** DTy *)
Module DecidableDTy <: Coq.Structures.DecidableType.DecidableType.

  Definition t := DTy.
  Definition eq : t -> t -> Prop := @Logic.eq t.

  Definition eq_refl  := @Logic.eq_refl  DTy.
  Definition eq_sym   := @Logic.eq_sym   DTy.
  Definition eq_trans := @Logic.eq_trans DTy.

  Definition eq_dec    := eq_DTy.
End DecidableDTy.

Module Import DTySI : WSfun DecidableDTy := FSetWeakList.Make DecidableDTy.
Notation DTyS := DTySI.t.
Module Import DTySD := WDecide_fun DecidableDTy DTySI.

(** DSch *)
Module DecidableDSch <: Coq.Structures.DecidableType.DecidableType.

  Definition t := DSch.
  Definition eq : t -> t -> Prop := @Logic.eq t.

  Definition eq_refl  := @Logic.eq_refl  DSch.
  Definition eq_sym   := @Logic.eq_sym   DSch.
  Definition eq_trans := @Logic.eq_trans DSch.

  Definition eq_dec    := eq_DSch.
End DecidableDSch.

Module Import DSchSI : WSfun DecidableDSch := FSetWeakList.Make DecidableDSch.
Notation DSchS := DSchSI.t.
Module Import DSchSD := WDecide_fun DecidableDSch DSchSI.

(** Pair with DTy *)
Definition eq_VarDTyDeciablePair : forall (x y : atom * DTy), {x = y} + {x <> y}.
Proof.
  intros. destruct x, y.
  destruct (Atom.eq_dec a a0). 2:right; congruence.
  destruct (eq_DTy d d0). 2:right; congruence.
  crush.
Qed.

Module DecidableDTyPair <: Coq.Structures.DecidableType.DecidableType.
  Definition t := (atom * DTy).
  Definition eq : t -> t -> Prop := @Logic.eq t.

  Definition eq_refl  := @Logic.eq_refl  t.
  Definition eq_sym   := @Logic.eq_sym   t.
  Definition eq_trans := @Logic.eq_trans t.

  Definition eq_dec    := eq_VarDTyDeciablePair.
End DecidableDTyPair.

Module Import DTyPSI : WSfun DecidableDTyPair := FSetWeakList.Make DecidableDTyPair.
Notation DTyPS := DTyPSI.t.
Module Import DTyPSD := WDecide_fun DecidableDTyPair DTyPSI.

(** Pair with DSch *)
Definition eq_VarDSchDeciablePair : forall (x y : atom * DSch), {x = y} + {x <> y}.
Proof.
  intros. destruct x, y.
  destruct (Atom.eq_dec a a0). 2:right; congruence.
  destruct (eq_DSch d d0). 2:right; congruence.
  crush.
Qed.

Module DecidableDSchPair <: Coq.Structures.DecidableType.DecidableType.
  Definition t := (termvar * DSch).
  Definition eq : t -> t -> Prop := @Logic.eq t.

  Definition eq_refl  := @Logic.eq_refl  t.
  Definition eq_sym   := @Logic.eq_sym   t.
  Definition eq_trans := @Logic.eq_trans t.

  Definition eq_dec    := eq_VarDSchDeciablePair.
End DecidableDSchPair.

Module Import DSchPSI : WSfun DecidableDSchPair := FSetWeakList.Make DecidableDSchPair.
Notation DSchPS := DSchPSI.t.
Module Import DSchPSD := WDecide_fun DecidableDSchPair DSchPSI.

(*** Algorithmic *)
(** DTy *)
Module DecidableTy <: Coq.Structures.DecidableType.DecidableType.

  Definition t := Ty.
  Definition eq : t -> t -> Prop := @Logic.eq t.

  Definition eq_refl  := @Logic.eq_refl  Ty.
  Definition eq_sym   := @Logic.eq_sym   Ty.
  Definition eq_trans := @Logic.eq_trans Ty.

  Definition eq_dec    := eq_Ty.
End DecidableTy.

Module Import TySI : WSfun DecidableTy := FSetWeakList.Make DecidableTy.
Notation TyS := TySI.t.
Module Import TySD := WDecide_fun DecidableTy TySI.

(** Sch *)
Module DecidableSch <: Coq.Structures.DecidableType.DecidableType.

  Definition t := Sch.
  Definition eq : t -> t -> Prop := @Logic.eq t.

  Definition eq_refl  := @Logic.eq_refl  Sch.
  Definition eq_sym   := @Logic.eq_sym   Sch.
  Definition eq_trans := @Logic.eq_trans Sch.

  Definition eq_dec    := eq_Sch.
End DecidableSch.

Module Import SchSI : WSfun DecidableSch := FSetWeakList.Make DecidableSch.
Notation SchS := SchSI.t.
Module Import SchSD := WDecide_fun DecidableSch SchSI.

(** Pair with Ty *)
Definition eq_VarTyDeciablePair : forall (x y : atom * Ty), {x = y} + {x <> y}.
Proof.
  intros. destruct x, y.
  destruct (Atom.eq_dec a a0). 2:right; congruence.
  destruct (eq_Ty t0 t1). 2:right; congruence.
  crush.
Qed.

Module DecidableTyPair <: Coq.Structures.DecidableType.DecidableType.
  Definition t := (atom * Ty).
  Definition eq : t -> t -> Prop := @Logic.eq t.

  Definition eq_refl  := @Logic.eq_refl  t.
  Definition eq_sym   := @Logic.eq_sym   t.
  Definition eq_trans := @Logic.eq_trans t.

  Definition eq_dec    := eq_VarTyDeciablePair.
End DecidableTyPair.

Module Import TyPSI : WSfun DecidableTyPair := FSetWeakList.Make DecidableTyPair.
Notation TyPS := TyPSI.t.
Module Import TyPSD := WDecide_fun DecidableTyPair TyPSI.

(* Pair with Sch *)
Definition eq_VarSchDeciablePair : forall (x y : atom * Sch), {x = y} + {x <> y}.
Proof.
  intros. destruct x, y.
  destruct (Atom.eq_dec a a0). 2:right; congruence.
  destruct (eq_Sch s s0). 2:right; congruence.
  crush.
Qed.

Module DecidableSchPair <: Coq.Structures.DecidableType.DecidableType.
  Definition t := (atom * Sch).
  Definition eq : t -> t -> Prop := @Logic.eq t.

  Definition eq_refl  := @Logic.eq_refl  t.
  Definition eq_sym   := @Logic.eq_sym   t.
  Definition eq_trans := @Logic.eq_trans t.

  Definition eq_dec    := eq_VarSchDeciablePair.
End DecidableSchPair.

Module Import SchPSI : WSfun DecidableSchPair := FSetWeakList.Make DecidableSchPair.
Notation SchPS := SchPSI.t.
Module Import SchPSD := WDecide_fun DecidableSchPair SchPSI.

(*** Instances *)
(** Atoms *)
#[global] Instance Atoms_SetProps : SetProps vars :=
  { SEqual     := AtomSetImpl.Equal
  ; SSubset    := AtomSetImpl.Subset
  ; Sunion     := AtomSetImpl.union
  ; Sempty     := AtomSetImpl.empty
  ; Selt       := atom
  ; Ssingleton := AtomSetImpl.singleton
  ; SIn        := AtomSetImpl.In
  }.

(** Declarative *)

(* DTy *)
#[global] Instance DTyS_SetProps : SetProps DTyS :=
  { SEqual     := DTySI.Equal
  ; SSubset    := DTySI.Subset
  ; Sunion     := DTySI.union
  ; Sempty     := DTySI.empty
  ; Selt       := DTySI.elt
  ; Ssingleton := DTySI.singleton
  ; SIn        := DTySI.In
  }.

(* DSch *)
#[global] Instance DSchS_SetProps : SetProps DSchS :=
  { SEqual     := DSchSI.Equal
  ; SSubset    := DSchSI.Subset
  ; Sunion     := DSchSI.union
  ; Sempty     := DSchSI.empty
  ; Selt       := DSchSI.elt
  ; Ssingleton := DSchSI.singleton
  ; SIn        := DSchSI.In
  }.

(* Pair with DTy *)
#[global] Instance DTyPS_SetProps : SetProps DTyPS :=
  { SEqual     := DTyPSI.Equal
  ; SSubset    := DTyPSI.Subset
  ; Sunion     := DTyPSI.union
  ; Sempty     := DTyPSI.empty
  ; Selt       := DTyPSI.elt
  ; Ssingleton := DTyPSI.singleton
  ; SIn        := DTyPSI.In
  }.

(* Pair with DSch *)
#[global] Instance DSchPS_SetProps : SetProps DSchPS :=
  { SEqual     := DSchPSI.Equal
  ; SSubset    := DSchPSI.Subset
  ; Sunion     := DSchPSI.union
  ; Sempty     := DSchPSI.empty
  ; Selt       := DSchPSI.elt
  ; Ssingleton := DSchPSI.singleton
  ; SIn        := DSchPSI.In
  }.

(** Algorithmic *)

(* Ty *)
#[global] Instance TyS_SetProps : SetProps TyS :=
  { SEqual     := TySI.Equal
  ; SSubset    := TySI.Subset
  ; Sunion     := TySI.union
  ; Sempty     := TySI.empty
  ; Selt       := TySI.elt
  ; Ssingleton := TySI.singleton
  ; SIn        := TySI.In
  }.

(* Sch *)
#[global] Instance SchS_SetProps : SetProps SchS :=
  { SEqual     := SchSI.Equal
  ; SSubset    := SchSI.Subset
  ; Sunion     := SchSI.union
  ; Sempty     := SchSI.empty
  ; Selt       := SchSI.elt
  ; Ssingleton := SchSI.singleton
  ; SIn        := SchSI.In
  }.

(* Pair with Ty *)
#[global] Instance TyPS_SetProps : SetProps TyPS :=
  { SEqual     := TyPSI.Equal
  ; SSubset    := TyPSI.Subset
  ; Sunion     := TyPSI.union
  ; Sempty     := TyPSI.empty
  ; Selt       := TyPSI.elt
  ; Ssingleton := TyPSI.singleton
  ; SIn        := TyPSI.In
  }.

(* Pair with Sch *)
#[global] Instance SchPS_SetProps : SetProps SchPS :=
  { SEqual     := SchPSI.Equal
  ; SSubset    := SchPSI.Subset
  ; Sunion     := SchPSI.union
  ; Sempty     := SchPSI.empty
  ; Selt       := SchPSI.elt
  ; Ssingleton := SchPSI.singleton
  ; SIn        := SchPSI.In
  }.

(*** Notations *)
Notation "E ⟪=⟫ F" :=
  (SEqual E F)
  (at level 70, no associativity).

Notation "E ⟪<=⟫ F" :=
  (SSubset E F)
  (at level 70, no associativity).

Notation "⟪⟫" :=
  (Sempty).

Notation "⟪⟪  x  ⟫⟫" :=
  (Ssingleton x).

Notation "E ∪ F" :=
  (Sunion E F)
  (at level 65, right associativity).

(** Declarative *)

(* DTy *)
Declare Scope DTyS_scope.
Bind Scope DTyS_scope with DTyS.
Notation "A \u B" := (DTySI.union A B  ) : DTyS_scope.
Notation "{}"     := (DTySI.empty      ) : DTyS_scope.
Notation "{ A }"  := (DTySI.singleton A) : DTyS_scope.

(* DSch *)
Declare Scope DSchS_scope.
Bind Scope DSchS_scope with DSchS.
Notation "A \u B" := (DSchSI.union A B  ) : DSchS_scope.
Notation "{}"     := (DSchSI.empty      ) : DSchS_scope.
Notation "{ A }"  := (DSchSI.singleton A) : DSchS_scope.

(* Pair with DTy *)
Declare Scope DTyPS_scope.
Bind Scope DTyPS_scope with DTyPS.
Notation "A \u B" := (DTyPSI.union A B  ) : DTyPS_scope.
Notation "{}"     := (DTyPSI.empty      ) : DTyPS_scope.
Notation "{ A }"  := (DTyPSI.singleton A) : DTyPS_scope.

(* Pair with DSch *)
Declare Scope DSchPS_scope.
Bind Scope DSchPS_scope with DSchPS.
Notation "A \u B" := (DSchPSI.union A B  ) : DSchPS_scope.
Notation "{}"     := (DSchPSI.empty      ) : DSchPS_scope.
Notation "{ A }"  := (DSchPSI.singleton A) : DSchPS_scope.

(** Algorithmic *)

(* Ty *)
Declare Scope TyS_scope.
Bind Scope TyS_scope with TyS.
Notation "A \u B" := (TySI.union A B  ) : TyS_scope.
Notation "{}"     := (TySI.empty      ) : TyS_scope.
Notation "{ A }"  := (TySI.singleton A) : TyS_scope.

(* Sch *)
Declare Scope SchS_scope.
Bind Scope SchS_scope with SchS.
Notation "A \u B" := (SchSI.union A B  ) : SchS_scope.
Notation "{}"     := (SchSI.empty      ) : SchS_scope.
Notation "{ A }"  := (SchSI.singleton A) : SchS_scope.

(* Pair with Ty *)
Declare Scope TyPS_scope.
Bind Scope TyPS_scope with TyPS.
Notation "A \u B" := (TyPSI.union A B  ) : TyPS_scope.
Notation "{}"     := (TyPSI.empty      ) : TyPS_scope.
Notation "{ A }"  := (TyPSI.singleton A) : TyPS_scope.

(* Pair with Sch *)
Declare Scope SchPS_scope.
Bind Scope SchPS_scope with SchPS.
Notation "A \u B" := (SchPSI.union A B  ) : SchPS_scope.
Notation "{}"     := (SchPSI.empty      ) : SchPS_scope.
Notation "{ A }"  := (SchPSI.singleton A) : SchPS_scope.

(*** Manual defs *)
Fixpoint emb_Ty (dty : DTy) : Ty :=
  match dty with
  | (DT_SkVar_b n    ) => T_SkVar_b n
  | (DT_SkVar_f skA  ) => T_SkVar_f skA
  | (DT_Unit         ) => T_Unit
  | (DT_Fun dty1 dty2) => T_Fun (emb_Ty dty1) (emb_Ty dty2)
end.

Fixpoint emb_Sch (dsch : DSch) : Sch :=
  match dsch with
  | (DS_Mono   dty ) => S_Mono   (emb_Ty dty)
  | (DS_Forall dsch) => S_Forall (emb_Sch dsch)
end.

Fixpoint generalize_DSch (dsch : DSch) (da : DA) : DSch :=
  match da with
  | nil => dsch
  | cons dskA da' =>
      let dsch := generalize_DSch dsch da' in
      DS_Forall (close_DSch_wrt_DTy dskA dsch)
end.

Fixpoint generalize_Sch (sch : Sch) (a : A) (L :  vars) : Sch :=
  match a with
  | nil => sch
  | cons exA a' =>
      let sch' := generalize_Sch sch a' L in
      let fr   := proj1_sig (atom_fresh (free_skvars_Sch sch' \u L)) in
      S_Forall (close_Sch_wrt_Ty fr (subst_exvar_Sch (T_SkVar_f fr) exA sch'))
end.

(*** eq lemmas *)
Lemma eq_A: forall (x y : list exvar), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_A : ott_coq_equality.
Lemma eq_Obj: forall (x y : Obj), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_Obj : ott_coq_equality.
Lemma eq_Env: forall (x y : Env), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_Env : ott_coq_equality.

(*** List stuff *)
(** DEnv to Set *)
Module List_to_Set (E : DecidableType) (Import M : WSfun E).
  Module Import Dec := WDecide_fun E M.
  Section List_to_Set.
    Context (elt : Type).
    Variable f : elt -> t.
    Definition List_to_Set : list elt -> t :=
      fold_right (union ∘ f) empty.
    (* Simplifications *)
    Theorem List_to_Set_app : forall (l1 l2 : list elt),
        List_to_Set (l1 ++ l2) [=] union (List_to_Set l1) (List_to_Set l2).
    Proof. intros; induction l1; simpl; autorewrite with core; fsetdec. Qed.
    Theorem List_to_Set_cons : forall (l : list elt) (x : elt),
        List_to_Set (x :: l) [=] union (List_to_Set l) (f x).
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.
    Theorem List_to_Set_one : forall (x : elt),
        List_to_Set (one x) [=] f x.
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.
    (* Facts *)
    Corollary List_to_Set_app_symm : forall (l1 l2 : list elt),
        List_to_Set (l1 ++ l2) [=] List_to_Set (l2 ++ l1).
    Proof. intros. do 2 rewrite List_to_Set_app. fsetdec. Qed.
  End List_to_Set.
  #[export] Hint Rewrite List_to_Set_app : List_to_Set.
  #[export] Hint Rewrite List_to_Set_cons : List_to_Set.
  #[export] Hint Rewrite List_to_Set_one : List_to_Set.
  #[export] Hint Resolve List_to_Set_app : core List_to_Set.
  #[export] Hint Resolve List_to_Set_cons : core List_to_Set.
  #[export] Hint Resolve List_to_Set_one : core List_to_Set.
  #[export] Hint Resolve List_to_Set_app_symm : core List_to_Set.
End List_to_Set.

Module Export List_to_Atoms := List_to_Set Atom AtomSetImpl.
Module Export List_to_DTyS := List_to_Set DecidableDTy DTySI.
Module Export List_to_DTySP := List_to_Set DecidableDTyPair DTyPSI.

Definition varl : A -> vars :=
  List_to_Atoms.List_to_Set atom (AtomSetImpl.singleton).

Definition DSub_codom : DSub -> DTyS :=
  List_to_DTyS.List_to_Set (exvar * DTy) (DTySI.singleton ∘ snd).
#[export] Hint Extern 2 =>
  match goal with
      | [ |- context[DSub_codom _] ] => unfold DSub_codom
    end : core.

Definition DSub_bindings : DSub -> DTyPS :=
  List_to_DTySP.List_to_Set (atom * DTy) (DTyPSI.singleton).
#[export] Hint Extern 2 =>
  match goal with
      | [ |- context[DSub_bindings _] ] => unfold DSub_bindings
    end : core.

Definition DSub_dom : DSub -> vars :=
  List_to_Atoms.List_to_Set (exvar * DTy) (AtomSetImpl.singleton ∘ fst).
#[export] Hint Extern 2 =>
  match goal with
      | [ |- context[DSub_dom _] ] => unfold DSub_dom
    end : core.

(** Sub stuff *)
Definition DSub_to_A : DSub -> A :=
  fold_right (cons ∘ fst) nil.

Definition DSub_codom_dskvars : DSub -> atoms :=
  List_to_Atoms.List_to_Set (exvar * DTy) (free_dskvars_DTy ∘ snd).
#[export] Hint Extern 2 =>
  match goal with
      | [ |- context[DSub_codom_dskvars _] ] => unfold DSub_codom_dskvars
    end : core.

Definition DSub_app_t : Ty -> DSub -> Ty := (fold_right (uncurry (flip (subst_exvar_Ty ∘ emb_Ty)))).

Fixpoint DSub_app (sch : Sch) (dsub : DSub) : Sch :=
  match sch with
  | S_Mono   t   => S_Mono   (DSub_app_t t   dsub)
  | S_Forall sch => S_Forall (DSub_app   sch dsub)
end.

Definition Sub_app_t : Ty -> Sub -> Ty := (fold_right (uncurry (flip subst_exvar_Ty))).

Fixpoint Sub_app (sch : Sch) (sub : Sub) : Sch :=
  match sch with
  | S_Mono   t   => S_Mono   (Sub_app_t t   sub)
  | S_Forall sch => S_Forall (Sub_app   sch sub)
end.

Definition bimap_tup {X:Type} {Y:Type} (f:X->Y) (tup:(X*X)) : (Y*Y) :=
  match tup with
    | (x,y) => (f x, f y)
  end.

Definition subst_exvar_Eqs : Ty -> exvar -> Eqs -> Eqs :=
  fun ty exA => Coq.Lists.List.map (bimap_tup (subst_exvar_Ty ty exA)).

Definition Sub_app_Eqs : Eqs -> Sub -> Eqs :=
  fold_right (uncurry (flip subst_exvar_Eqs)).

Definition Sub_app_Env : Env -> Sub -> Env :=
  fold_right (uncurry (flip subst_exvar_Env)).

(*** Obj stuff *)
Section Sec_fold_DObj.
  Context {S : Type}.
  Variable f : DA -> DSch -> S.

  Definition fold_DObj (dobj : DObj) :=
    match dobj with
    | DObj_DSch a dsch => f a dsch
  end.
End Sec_fold_DObj.

Section Sec_fold_Obj.
  Context {S : Type}.
  Variable f : A -> Sch -> S.

  Definition fold_Obj (obj : Obj) :=
    match obj with
    | Obj_Sch a sch => f a sch
  end.
End Sec_fold_Obj.

(*** Fold-based Defs *)
(** DEnv fold *)
Section Sec_DEnv_fold.
  Context {S : Type}.
  Variable s0     :                      S.
  Variable f__dskol : S -> dskvar         -> S.
  Variable f__var   : S -> termvar * DSch -> S.
  Variable f__dobj  : S -> DObj           -> S.

  Fixpoint DEnv_fold (denv:DEnv) : S :=
    match denv with
      | DEnv_Empty              => s0
      | DEnv_DSkol denv' dskA   => f__dskol (DEnv_fold denv') dskA
      | DEnv_DVar  denv' x dsch => f__var   (DEnv_fold denv') (x, dsch)
      | DEnv_DObj  denv' dobj   => f__dobj  (DEnv_fold denv') dobj
    end.
End Sec_DEnv_fold.

Definition DEnv_app : DEnv -> DEnv -> DEnv := fun denv1 =>
  DEnv_fold denv1 DEnv_DSkol (fun denv => uncurry (DEnv_DVar denv)) DEnv_DObj.

(** DEnv to Set *)
Module DEnv_to_Set (E : DecidableType) (Import M : WSfun E).
  Module Import Dec := WDecide_fun E M.

  Section Denv_to_Set.
    Variable f__a : dskvar         -> t.
    Variable f__x : termvar * DSch -> t.
    Variable f__o : DObj           -> t.

    Definition DEnv_to_Set : DEnv -> t :=
      DEnv_fold empty (flip (union ∘ f__a)) (flip (union ∘ f__x)) (flip (union ∘ f__o)).

    Theorem DEnv_to_Set_app : forall (denv1 denv2 : DEnv),
        DEnv_to_Set (DEnv_app denv1 denv2) [=] union (DEnv_to_Set denv1) (DEnv_to_Set denv2).
    Proof. induction denv2; simpl; autorewrite with core; fsetdec. Qed.

    Theorem DEnv_to_Set_s : forall (denv : DEnv) (dskA : dskvar),
        DEnv_to_Set (DEnv_DSkol denv dskA) [=] union (DEnv_to_Set denv) (f__a dskA).
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.

    Theorem DEnv_to_Set_a : forall (denv : DEnv) (da : DA),
        DEnv_to_Set (DEnv_DA denv da) [=] union (DEnv_to_Set denv) (fold_right (union ∘ f__a) empty da).
    Proof. intros. induction da. fsetdec. simpl. autorewrite with core. fsetdec. Qed.

    Theorem DEnv_to_Set_x : forall (denv : DEnv) (x : termvar) (dsch : DSch),
        DEnv_to_Set (DEnv_DVar denv x dsch) [=] union (DEnv_to_Set denv) (f__x (x, dsch)).
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.

    Theorem DEnv_to_Set_o : forall (denv : DEnv) (dobj : DObj),
        DEnv_to_Set (DEnv_DObj denv dobj) [=] union (DEnv_to_Set denv) (f__o dobj).
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.

    Theorem DEnv_to_Set_ones : forall (dskA : dskvar),
        DEnv_to_Set (oneDS dskA) [=] f__a dskA.
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.

    Theorem DEnv_to_Set_onea : forall (da : DA),
        DEnv_to_Set (oneDA da) [=] fold_right (union ∘ f__a) empty da.
    Proof. intros. induction da. fsetdec. simpl. autorewrite with core. fsetdec. Qed.

    Theorem DEnv_to_Set_onex : forall (x : termvar) (dsch : DSch),
        DEnv_to_Set (oneDX x dsch) [=] f__x (x, dsch).
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.

    Theorem DEnv_to_Set_oneo : forall (dobj : DObj),
        DEnv_to_Set (oneDO dobj) [=] f__o dobj.
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.

  End Denv_to_Set.
  #[export] Hint Rewrite DEnv_to_Set_app : DEnv_to_Set.
  #[export] Hint Rewrite DEnv_to_Set_s : DEnv_to_Set.
  #[export] Hint Rewrite DEnv_to_Set_a : DEnv_to_Set.
  #[export] Hint Rewrite DEnv_to_Set_x : DEnv_to_Set.
  #[export] Hint Rewrite DEnv_to_Set_o : DEnv_to_Set.
  #[export] Hint Rewrite DEnv_to_Set_ones : DEnv_to_Set.
  #[export] Hint Rewrite DEnv_to_Set_onea : DEnv_to_Set.
  #[export] Hint Rewrite DEnv_to_Set_onex : DEnv_to_Set.
  #[export] Hint Rewrite DEnv_to_Set_oneo : DEnv_to_Set.

  #[export] Hint Resolve DEnv_to_Set_app : core DEnv_to_Set.
  #[export] Hint Resolve DEnv_to_Set_s : core DEnv_to_Set.
  #[export] Hint Resolve DEnv_to_Set_a : core DEnv_to_Set.
  #[export] Hint Resolve DEnv_to_Set_x : core DEnv_to_Set.
  #[export] Hint Resolve DEnv_to_Set_o : core DEnv_to_Set.
  #[export] Hint Resolve DEnv_to_Set_ones : core DEnv_to_Set.
  #[export] Hint Resolve DEnv_to_Set_onea : core DEnv_to_Set.
  #[export] Hint Resolve DEnv_to_Set_onex : core DEnv_to_Set.
  #[export] Hint Resolve DEnv_to_Set_oneo : core DEnv_to_Set.

  Theorem fold_empty_empty : forall (da : DA),
      fold_right (union ∘ const empty) empty da [=] empty.
  Proof. intros. induction da; crush. fsetdec. Qed.
  #[export] Hint Rewrite fold_empty_empty : DEnv_to_Set.
  #[export] Hint Resolve fold_empty_empty : core DEnv_to_Set.
End DEnv_to_Set.

Module Export DEnv_to_Atoms  := DEnv_to_Set Atom AtomSetImpl.
Module Export DEnv_to_DSchPS := DEnv_to_Set DecidableDSchPair DSchPSI.
Module Export DEnv_to_DSchS  := DEnv_to_Set DecidableDSch     DSchSI .

Definition DEnv_dskvars : DEnv -> vars :=
  DEnv_to_Atoms.DEnv_to_Set AtomSetImpl.singleton (const Sempty) (const Sempty).

Definition DEnv_bindings : DEnv -> DSchPS :=
  DEnv_to_DSchPS.DEnv_to_Set (const Sempty) DSchPSI.singleton (const Sempty).

Definition DEnv_boundvars : DEnv -> vars :=
  DEnv_to_Atoms.DEnv_to_Set (const Sempty) (AtomSetImpl.singleton ∘ fst) (const Sempty).

Definition DEnv_DSchs : DEnv -> DSchS :=
  DEnv_to_DSchS.DEnv_to_Set (const Sempty) (DSchSI.singleton ∘ snd) (const Sempty).

(** Env fold *)
Section Sec_Env_fold.
  Context {S : Type}.
  Variable s0     :                       S.
  Variable f__skol  : S -> skvar           -> S.
  Variable f__a     : S -> A               -> S.
  Variable f__var   : S -> (termvar * Sch) -> S.
  Variable f__obj   : S -> Obj             -> S.

  Fixpoint Env_fold (env:Env) : S :=
    match env with
      | Env_Empty            => s0
      | Env_Skol  env' skA   => f__skol (Env_fold env') skA
      | Env_A     env' a     => f__a    (Env_fold env') a
      | Env_Var   env' x sch => f__var  (Env_fold env') (x, sch)
      | Env_Obj   env' obj   => f__obj  (Env_fold env') obj
    end.
End Sec_Env_fold.

Definition Env_app : Env -> Env -> Env := fun env1 =>
  Env_fold env1 Env_Skol Env_A (fun env => uncurry (Env_Var env)) Env_Obj.

Definition Env_length : Env -> nat :=
  Env_fold 0
    (const ∘ (plus 1))
    (const ∘ (plus 1))
    (const ∘ (plus 1))
    (const ∘ (plus 1)).

(** Env to Set *)
Module Env_to_Set (E : DecidableType) (Import M : WSfun E).
  Module Import Dec := WDecide_fun E M.

  Section Env_to_Set.

    Variable f__s : skvar         -> t.
    Variable f__a : A             -> t.
    Variable f__x : termvar * Sch -> t.
    Variable f__o : Obj           -> t.

    Definition Env_to_Set : Env -> t :=
      Env_fold empty (flip (union ∘ f__s)) (flip (union ∘ f__a)) (flip (union ∘ f__x)) (flip (union ∘ f__o)).

    Theorem Env_to_Set_app : forall (env1 env2 : Env),
        Env_to_Set (Env_app env1 env2) [=] union (Env_to_Set env1) (Env_to_Set env2).
    Proof. induction env2; simpl; autorewrite with core; fsetdec. Qed.

    Theorem Env_to_Set_s : forall (env : Env) (skA : skvar),
        Env_to_Set (Env_Skol env skA) [=] union (Env_to_Set env) (f__s skA).
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.

    Theorem Env_to_Set_a : forall (env : Env) (a : A),
        Env_to_Set (Env_A env a) [=] union (Env_to_Set env) (f__a a).
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.

    Theorem Env_to_Set_x : forall (env : Env) (x : termvar) (sch : Sch),
        Env_to_Set (Env_Var env x sch) [=] union (Env_to_Set env) (f__x (x, sch)).
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.

    Theorem Env_to_Set_o : forall (env : Env) (obj : Obj),
        Env_to_Set (Env_Obj env obj) [=] union (Env_to_Set env) (f__o obj).
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.

    Theorem Env_to_Set_ones : forall (skA : skvar),
        Env_to_Set (oneS skA) [=] f__s skA.
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.

    Theorem Env_to_Set_onea : forall (a : A),
        Env_to_Set (oneA a) [=] f__a a.
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.

    Theorem Env_to_Set_onex : forall (x : termvar) (sch : Sch),
        Env_to_Set (oneX x  sch) [=] f__x (x, sch).
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.

    Theorem Env_to_Set_oneo : forall (obj : Obj),
        Env_to_Set (oneO obj) [=] f__o obj.
    Proof. intros. simpl; autorewrite with core; fsetdec. Qed.

    (** Gives problems, don't know why *)
    (* Theorem Env_to_Set_empty : *)
    (*     Env_to_Set Env_Empty [=] empty. *)
    (* Proof. intros. simpl. reflexivity. Qed. *)
  End Env_to_Set.
  #[export] Hint Rewrite Env_to_Set_app : Env_to_Set.
  #[export] Hint Rewrite Env_to_Set_s : Env_to_Set.
  #[export] Hint Rewrite Env_to_Set_a : Env_to_Set.
  #[export] Hint Rewrite Env_to_Set_x : Env_to_Set.
  #[export] Hint Rewrite Env_to_Set_o : Env_to_Set.
  #[export] Hint Rewrite Env_to_Set_ones : Env_to_Set.
  #[export] Hint Rewrite Env_to_Set_onea : Env_to_Set.
  #[export] Hint Rewrite Env_to_Set_onex : Env_to_Set.
  #[export] Hint Rewrite Env_to_Set_oneo : Env_to_Set.
  (* #[export] Hint Rewrite Env_to_Set_empty : Env_to_Set. *)

  #[export] Hint Resolve Env_to_Set_app : core Env_to_Set.
  #[export] Hint Resolve Env_to_Set_s : core Env_to_Set.
  #[export] Hint Resolve Env_to_Set_a : core Env_to_Set.
  #[export] Hint Resolve Env_to_Set_x : core Env_to_Set.
  #[export] Hint Resolve Env_to_Set_o : core Env_to_Set.
  #[export] Hint Resolve Env_to_Set_ones : core Env_to_Set.
  #[export] Hint Resolve Env_to_Set_onea : core Env_to_Set.
  #[export] Hint Resolve Env_to_Set_onex : core Env_to_Set.
  #[export] Hint Resolve Env_to_Set_oneo : core Env_to_Set.
  (* #[export] Hint Resolve Env_to_Set_empty : core Env_to_Set. *)
End Env_to_Set.

Module Export Env_to_Atoms := Env_to_Set Atom AtomSetImpl.
Module Export Env_to_SchPS := Env_to_Set DecidableSchPair SchPSI.
Module Export Env_to_SchS  := Env_to_Set DecidableSch SchSI.

Definition Env_skvars : Env -> vars :=
  Env_to_Atoms.Env_to_Set AtomSetImpl.singleton (const Sempty) (const Sempty) (const Sempty).

Definition Env_exvars : Env -> vars :=
  Env_to_Atoms.Env_to_Set (const Sempty) varl (const Sempty) (const Sempty).

Definition Obj_exvars : Obj -> vars :=
  fold_Obj (flip (const varl)).

Definition Obj_to_Sch : Obj -> Sch :=
  fold_Obj (flip const).

Definition Env_Obj_exvars : Env -> vars :=
  Env_to_Atoms.Env_to_Set (const Sempty) varl (const Sempty) Obj_exvars.

Definition Env_bindings : Env -> SchPS :=
  Env_to_SchPS.Env_to_Set (const Sempty) (const Sempty) SchPSI.singleton (const Sempty).

Definition Env_boundvars : Env -> vars :=
  Env_to_Atoms.Env_to_Set (const Sempty) (const Sempty) (AtomSetImpl.singleton ∘ fst) (const Sempty).

Definition Env_Schs : Env -> SchS :=
  Env_to_SchS.Env_to_Set (const Sempty) (const Sempty) (SchSI.singleton ∘ snd) (const Sempty).

Definition Env_Obj_Schs : Env -> SchS :=
  Env_to_SchS.Env_to_Set (const Sempty) (const Sempty) (SchSI.singleton ∘ snd) (SchSI.singleton ∘ Obj_to_Sch).

(** Env, direct recursion *)
Fixpoint Env_drop (n : nat) (env : Env): Env :=
  match n with
    | 0     => env
    | (S n) =>
        match env with
          | (Env_Empty        ) => Env_Empty
          | ( (Env_Skol env' _  )
            | (Env_A    env' _  )
            | (Env_Var  env' _ _)
            | (Env_Obj  env' _  )
            ) => Env_drop n env'
        end
  end.

(* Local Variables: *)
(* company-coq-local-symbols: (("|=" . ?⊨) ("=|" . ?⫤) ("->>" . ?↠) ("=~" . ?≈) ("<|" . ?⟨) ("|>" . ?⟩)); *)
(* End: *)

(** definitions *)

(* defns DecHelpers *)
Inductive DFrA : DA -> DEnv -> Prop :=    (* defn DFrA *)
 | DFrANil : forall (DEnv5:DEnv),
      True  ->
     DFrA  nil  DEnv5
 | DFrACons : forall (DA5:DA) (dskA:dskvar) (DEnv5:DEnv)
     (DFRA: DFrA DA5 DEnv5)
     (DFR:  ( dskA  `notin` (DEnv_dskvars   ( DEnv_DA  DEnv5   DA5  )  ) ) ),
     DFrA  ( cons  dskA   DA5  )  DEnv5.

(* defns DecTyping *)
Inductive TmMon : DEnv -> e -> DTy -> Prop :=    (* defn TmMon *)
 | TmVar : forall (DEnv5:DEnv) (x:termvar) (DTy5:DTy) (DSch5:DSch)
     (IN:  (DSchPSI.In ( x , DSch5 ) (DEnv_bindings  DEnv5 ) ) )
     (SS: SubSump DEnv5 DSch5 (DS_Mono DTy5)),
     TmMon DEnv5 (e_Var_f x) DTy5
 | TmUnit : forall (DEnv5:DEnv),
      True  ->
     TmMon DEnv5 e_Unit DT_Unit
 | TmAbs : forall (L:vars) (DEnv5:DEnv) (e5:e) (DTy1 DTy2:DTy)
     (WFDTY: WfDTy DEnv5 (DS_Mono DTy1))
     (MON:  ( forall x , x \notin  L  -> TmMon (DEnv_DVar DEnv5 x (DS_Mono DTy1))  ( open_e_wrt_e e5 (e_Var_f x) )  DTy2 ) ),
     TmMon DEnv5 (e_Lam e5) (DT_Fun DTy1 DTy2)
 | TmApp : forall (DEnv5:DEnv) (e1 e2:e) (DTy2 DTy1:DTy)
     (MONe1: TmMon DEnv5 e1 (DT_Fun DTy1 DTy2))
     (MONe2: TmMon DEnv5 e2 DTy1),
     TmMon DEnv5 (e_App e1 e2) DTy2
 | TmLet : forall (L:vars) (DEnv5:DEnv) (e1 e2:e) (DTy5:DTy) (DSch5:DSch)
     (POL: TmDGen DEnv5 e1 DSch5)
     (MON:  ( forall x , x \notin  L  -> TmMon (DEnv_DVar DEnv5 x DSch5)  ( open_e_wrt_e e2 (e_Var_f x) )  DTy5 ) ),
     TmMon DEnv5  (e_Let e1 e2)  DTy5
with TmDGen : DEnv -> e -> DSch -> Prop :=    (* defn TmDGen *)
 | TmGen : forall (DEnv5:DEnv) (e5:e) (DSch5:DSch) (DA5:DA) (DTy5:DTy)
     (FR: DFrA DA5 DEnv5)
     (MON: TmMon  ( DEnv_DA  DEnv5   DA5  )  e5 DTy5),
      (generalize_DSch  (DS_Mono DTy5)   DA5  =  DSch5 )  ->
     TmDGen DEnv5 e5 DSch5
with WfDTy : DEnv -> DSch -> Prop :=    (* defn WfDTy *)
 | WfDTySk : forall (DEnv5:DEnv) (dskA:dskvar)
     (IN:  ( dskA  `in` (DEnv_dskvars  DEnv5 ) ) ),
     WfDTy DEnv5 (DS_Mono (DT_SkVar_f dskA))
 | WfDTyUnit : forall (DEnv5:DEnv),
      True  ->
     WfDTy DEnv5 (DS_Mono DT_Unit)
 | WfDTyArr : forall (DEnv5:DEnv) (DTy1 DTy2:DTy)
     (WFDTY1: WfDTy DEnv5 (DS_Mono DTy1))
     (WFDTY2: WfDTy DEnv5 (DS_Mono DTy2)),
     WfDTy DEnv5 (DS_Mono (DT_Fun DTy1 DTy2))
 | WfDTyAbs : forall (L:vars) (DEnv5:DEnv) (DSch5:DSch)
     (WFDTY:  ( forall dskA , dskA \notin  L  -> WfDTy (DEnv_DSkol DEnv5 dskA)  ( open_DSch_wrt_DTy DSch5 (DT_SkVar_f dskA) )  ) ),
     WfDTy DEnv5 (DS_Forall DSch5)
with WfDEnv : DEnv -> Prop :=    (* defn WfDEnv *)
 | WfDEnvNil : 
     WfDEnv DEnv_Empty
 | WfDEnvSk : forall (DEnv5:DEnv) (dskA:dskvar)
     (WFD: WfDEnv DEnv5)
     (FR:  ( dskA  `notin` (DEnv_dskvars  DEnv5 ) ) ),
     WfDEnv (DEnv_DSkol DEnv5 dskA)
 | WfDEnvSch : forall (DEnv5:DEnv) (x:termvar) (DSch5:DSch)
     (WFD: WfDEnv DEnv5)
     (WFDTY: WfDTy DEnv5 DSch5),
     WfDEnv (DEnv_DVar DEnv5 x DSch5)
with SubSump : DEnv -> DSch -> DSch -> Prop :=    (* defn SubSump *)
 | SubSumpMono : forall (DEnv5:DEnv) (DTy5:DTy),
      True  ->
      True  ->
     SubSump DEnv5 (DS_Mono DTy5) (DS_Mono DTy5)
 | SubSumpSkol : forall (L:vars) (DEnv5:DEnv) (DSch1 DSch2:DSch)
     (SS:  ( forall dskA , dskA \notin  L  -> SubSump (DEnv_DSkol DEnv5 dskA) DSch1  ( open_DSch_wrt_DTy DSch2 (DT_SkVar_f dskA) )  ) ),
     SubSump DEnv5 DSch1 (DS_Forall DSch2)
 | SubSumpInst : forall (L:vars) (DEnv5:DEnv) (DSch5:DSch) (DTy2 DTy1:DTy)
     (WFDTY: WfDTy DEnv5 (DS_Mono DTy1))
     (SS:  ( forall dskA , dskA \notin  L  -> SubSump DEnv5  ( subst_dskvar_DSch  DTy1   dskA    ( open_DSch_wrt_DTy DSch5 (DT_SkVar_f dskA) )   )  (DS_Mono DTy2) ) ),
     SubSump DEnv5 (DS_Forall DSch5) (DS_Mono DTy2).

(* defns AFreshNess *)
Inductive FrA : A -> Env -> Prop :=    (* defn FrA *)
 | FrANil : forall (Env5:Env),
      True  ->
     FrA  nil  Env5
 | FrACons : forall (A5:A) (exA:exvar) (Env5:Env)
     (FRA: FrA A5 Env5)
     (FR:  ( exA  `in` (Env_Obj_exvars  (Env_A Env5 A5) ) -> False ) ),
     FrA  ( cons  exA   A5  )  Env5.

(* defns AlgorithmicSystem *)
Inductive Inf : Env -> e -> A -> Ty -> Env -> Prop :=    (* defn Inf *)
 | InfVar : forall (Env5:Env) (x:termvar) (A5:A) (Ty5:Ty) (Sch5:Sch)
     (IN:  (In ( x , Sch5 ) (Env_bindings  Env5 ) ) )
     (INST: Inst Env5 Sch5 A5 Ty5),
     Inf Env5 (e_Var_f x) A5 Ty5 Env5
 | InfUnit : forall (Env5:Env),
      True  ->
     Inf Env5 e_Unit  nil  T_Unit Env5
 | InfAbs : forall (L:vars) (Envin:Env) (e5:e) (A1 A2:A) (Ty1 Ty2:Ty) (Envout:Env) (exA:exvar)
     (FR:  ( exA  `in` (Env_Obj_exvars  Envin ) -> False ) )
     (INF:  ( forall x , x \notin  L  -> Inf (Env_Var (Env_A Envin  (  exA  :: nil ) ) x (S_Mono (T_ExVar exA)))  ( open_e_wrt_e e5 (e_Var_f x) )  A2 Ty2 (Env_Var (Env_A Envout A1) x (S_Mono Ty1)) ) ),
     Inf Envin (e_Lam e5)  (  A2  ++  A1  )  (T_Fun Ty1 Ty2) Envout
 | InfApp : forall (Envin:Env) (e1 e2:e) (Aout:A) (Ty2:Ty) (Envout:Env) (exB:exvar) (Env2:Env) (A1' A2 A1:A) (Ty_5:Ty) (Env1:Env) (Ty1 Ty':Ty)
     (FR:  ( exB  `in` (Env_Obj_exvars  (Env_A Env2   (  A2  ++  A1'  )  ) ) -> False ) )
     (INFe1: Inf Envin e1 A1 Ty_5 Env1)
     (INFe2: Inf (Env_Obj Env1 (Obj_Sch A1 (S_Mono Ty_5))) e2 A2 Ty1 (Env_Obj Env2 (Obj_Sch A1' (S_Mono Ty'))))
     (UNI: U (Env_Obj (Env_A Env2  (    ( cons  exB   A2  )    ++  A1'  ) )  ( Obj_Sch nil  (S_Mono (T_ExVar exB))  ) )  ( ( Ty' , (T_Fun Ty1 (T_ExVar exB)) ) :: nil )  (Env_Obj (Env_A Envout Aout)  ( Obj_Sch nil  (S_Mono Ty2)  ) )),
     Inf Envin (e_App e1 e2) Aout Ty2 Envout
 | InfLet : forall (L:vars) (Envin:Env) (e1 e2:e) (A2:A) (Ty2:Ty) (Envout:Env) (Sch5:Sch) (Env_5:Env) (Sch':Sch)
     (POL: Gen Envin e1 Sch5 Env_5)
     (INF:  ( forall x , x \notin  L  -> Inf (Env_Var Env_5 x Sch5)  ( open_e_wrt_e e2 (e_Var_f x) )  A2 Ty2 (Env_Var Envout x Sch') ) ),
     Inf Envin (e_Let e1 e2) A2 Ty2 Envout
with Gen : Env -> e -> Sch -> Env -> Prop :=    (* defn Gen *)
 | InfGen : forall (Envin:Env) (e5:e) (Sch5:Sch) (Envout:Env) (A5:A) (Ty5:Ty)
     (MON: Inf Envin e5 A5 Ty5 Envout),
      (generalize_Sch  (S_Mono Ty5)   A5  AtomSetImpl.empty =  Sch5 )  ->
     Gen Envin e5 Sch5 Envout
with Inst : Env -> Sch -> A -> Ty -> Prop :=    (* defn Inst *)
 | InstMono : forall (Env5:Env) (Ty5:Ty),
      True  ->
      True  ->
     Inst Env5 (S_Mono Ty5)  nil  Ty5
 | InstPoly : forall (L:vars) (Env5:Env) (Sch5:Sch) (exA:exvar) (A5:A) (Ty5:Ty)
     (FR:  ( exA  `in` (Env_Obj_exvars  Env5 ) -> False ) )
     (INST:  ( forall skA , skA \notin  L  -> Inst (Env_A Env5  (  exA  :: nil ) )  ( subst_skvar_Sch  (T_ExVar exA)   skA    ( open_Sch_wrt_Ty Sch5 (T_SkVar_f skA) )   )  A5 Ty5 ) ),
     Inst Env5 (S_Forall Sch5)  (  A5  ++   (  exA  :: nil )   )  Ty5
with U : Env -> Eqs -> Env -> Prop :=    (* defn U *)
 | UU : forall (Envin:Env) (Eqs5:Eqs) (Envout:Env) (Sub5:Sub)
     (Us: Us Envin Eqs5 Envout Sub5),
     U Envin Eqs5 Envout
with Us : Env -> Eqs -> Env -> Sub -> Prop :=    (* defn Us *)
 | UsNil : forall (Env5:Env),
      True  ->
     Us Env5  nil  Env5  nil 
 | UsCons : forall (Envin:Env) (Eqs5:Eqs) (Envout:Env) (Sub1 Sub2:Sub) (Env_5:Env) (Eqs':Eqs)
     (UNI: Uss Envin Eqs5 Env_5 Eqs' Sub1)
     (USS: Us  ( Sub_app_Env  Env_5   Sub1  )   ( Sub_app_Eqs  Eqs'   Sub1  )  Envout Sub2),
     Us Envin Eqs5 Envout  ( Sub2  ++  Sub1 ) 
with Uss : Env -> Eqs -> Env -> Eqs -> Sub -> Prop :=    (* defn Uss *)
 | UssUnit : forall (Env5:Env) (Eqs5:Eqs),
      True  ->
     Uss Env5  ( ( T_Unit , T_Unit ) ::  Eqs5  )  Env5 Eqs5  nil 
 | UssExA : forall (Env5:Env) (exA:exvar) (Eqs5:Eqs),
      True  ->
     Uss Env5  ( ( (T_ExVar exA) , (T_ExVar exA) ) ::  Eqs5  )  Env5 Eqs5  nil 
 | UssDistrArr : forall (Env5:Env) (Ty1 Ty2 Ty3 Ty4:Ty) (Eqs5:Eqs),
      True  ->
      True  ->
      True  ->
      True  ->
      True  ->
     Uss Env5  ( (  (T_Fun Ty1 Ty2)  ,  (T_Fun Ty3 Ty4)  ) ::  Eqs5  )  Env5  ( ( Ty1 , Ty3 ) ::   ( ( Ty2 , Ty4 ) ::  Eqs5  )   )   nil 
 | UssSplitL : forall (Env1:Env) (A1:A) (exA:exvar) (A2:A) (Env2:Env) (Ty1 Ty2:Ty) (Eqs5:Eqs) (exA1 exA2:exvar)
     (FR: FrA  ( cons  exA2  ( exA1  :: nil) )   (Env_app  (Env_A Env1   (  A2  ++   ( cons  exA   A1  )   )  )   Env2 ) ),
      True  ->
      True  ->
      True  ->
      ( exA  `notin` (free_exvars_Ty  (T_Fun Ty1 Ty2) ) )  ->
     Uss  (Env_app  (Env_A Env1   (  A2  ++   ( cons  exA   A1  )   )  )   Env2 )   ( ( (T_ExVar exA) ,  (T_Fun Ty1 Ty2)  ) ::  Eqs5  )   (Env_app  (Env_A Env1   (  A2  ++   ( cons  exA2    ( cons  exA1   A1  )   )   )  )   Env2 )   ( ( (T_Fun (T_ExVar exA1) (T_ExVar exA2)) , (T_Fun Ty1 Ty2) ) ::  Eqs5  )   ( (  exA ,  (T_Fun (T_ExVar exA1) (T_ExVar exA2))  ) :: nil) 
 | UssSplitR : forall (Env1:Env) (A1:A) (exA:exvar) (A2:A) (Env2:Env) (Ty1 Ty2:Ty) (Eqs5:Eqs) (exA1 exA2:exvar)
     (FR: FrA  ( cons  exA2  ( exA1  :: nil) )   (Env_app  (Env_A Env1   (  A2  ++   ( cons  exA   A1  )   )  )   Env2 ) ),
      True  ->
      True  ->
      True  ->
      ( exA  `notin` (free_exvars_Ty  (T_Fun Ty1 Ty2) ) )  ->
     Uss  (Env_app  (Env_A Env1   (  A2  ++   ( cons  exA   A1  )   )  )   Env2 )   ( (  (T_Fun Ty1 Ty2)  , (T_ExVar exA) ) ::  Eqs5  )   (Env_app  (Env_A Env1   (  A2  ++   ( cons  exA2    ( cons  exA1   A1  )   )   )  )   Env2 )   ( ( (T_Fun Ty1 Ty2) , (T_Fun (T_ExVar exA1) (T_ExVar exA2)) ) ::  Eqs5  )   ( (  exA ,  (T_Fun (T_ExVar exA1) (T_ExVar exA2))  ) :: nil) 
 | UssSubExL : forall (Env1:Env) (A1:A) (exB:exvar) (A2:A) (Env2:Env) (exA:exvar) (Eqs5:Eqs),
      True  ->
      ( exA  `in` (Env_exvars  (Env_A Env1 A1) ) )  ->
     Uss  (Env_app  (Env_A Env1   (  A2  ++   ( cons  exB   A1  )   )  )   Env2 )   ( ( (T_ExVar exA) , (T_ExVar exB) ) ::  Eqs5  )   (Env_app  (Env_A Env1   (  A2  ++  A1  )  )   Env2 )  Eqs5  ( (  exB ,  (T_ExVar exA)  ) :: nil) 
 | UssSubExR : forall (Env1:Env) (A1:A) (exB:exvar) (A2:A) (Env2:Env) (exA:exvar) (Eqs5:Eqs),
      True  ->
      ( exA  `in` (Env_exvars  (Env_A Env1 A1) ) )  ->
     Uss  (Env_app  (Env_A Env1   (  A2  ++   ( cons  exB   A1  )   )  )   Env2 )   ( ( (T_ExVar exB) , (T_ExVar exA) ) ::  Eqs5  )   (Env_app  (Env_A Env1   (  A2  ++  A1  )  )   Env2 )  Eqs5  ( (  exB ,  (T_ExVar exA)  ) :: nil) 
 | UssSubUnitAL : forall (Env1:Env) (A1:A) (exA:exvar) (A2:A) (Env2:Env) (Eqs5:Eqs),
      True  ->
      True  ->
     Uss  (Env_app  (Env_A Env1   (  A2  ++   ( cons  exA   A1  )   )  )   Env2 )   ( ( T_Unit , (T_ExVar exA) ) ::  Eqs5  )   (Env_app  (Env_A Env1   (  A2  ++  A1  )  )   Env2 )  Eqs5  ( (  exA ,  T_Unit  ) :: nil) 
 | UssSubUnitAR : forall (Env1:Env) (A1:A) (exA:exvar) (A2:A) (Env2:Env) (Eqs5:Eqs),
      True  ->
      True  ->
     Uss  (Env_app  (Env_A Env1   (  A2  ++   ( cons  exA   A1  )   )  )   Env2 )   ( ( (T_ExVar exA) , T_Unit ) ::  Eqs5  )   (Env_app  (Env_A Env1   (  A2  ++  A1  )  )   Env2 )  Eqs5  ( (  exA ,  T_Unit  ) :: nil) .

(* defns WFAlgorithmic *)
Inductive WfTy : Env -> Sch -> Prop :=    (* defn WfTy *)
 | WfTySk : forall (Env5:Env) (skA:skvar)
     (IN:  ( skA  `in` (Env_skvars  Env5 ) ) ),
     WfTy Env5 (S_Mono (T_SkVar_f skA))
 | WfTyEx : forall (Env5:Env) (exA:exvar)
     (IN:  ( exA  `in` (Env_exvars  Env5 ) ) ),
     WfTy Env5 (S_Mono (T_ExVar exA))
 | WfTyUnit : forall (Env5:Env),
      True  ->
     WfTy Env5 (S_Mono T_Unit)
 | WfTyArr : forall (Env5:Env) (Ty1 Ty2:Ty)
     (WFTYt1: WfTy Env5 (S_Mono Ty1))
     (WFTYt2: WfTy Env5 (S_Mono Ty2)),
     WfTy Env5 (S_Mono (T_Fun Ty1 Ty2))
 | WfTyAbs : forall (L:vars) (Env5:Env) (Sch5:Sch)
     (WFTY:  ( forall skA , skA \notin  L  -> WfTy (Env_Skol Env5 skA)  ( open_Sch_wrt_Ty Sch5 (T_SkVar_f skA) )  ) ),
     WfTy Env5 (S_Forall Sch5)
with WfEnv : Env -> Prop :=    (* defn WfEnv *)
 | WfEnvNil : 
     WfEnv Env_Empty
 | WfEnvA : forall (Env5:Env) (A5:A)
     (WF: WfEnv Env5)
     (FR: FrA A5 Env5),
     WfEnv (Env_A Env5 A5)
 | WfEnvSch : forall (Env5:Env) (x:termvar) (Sch5:Sch)
     (WF: WfEnv Env5)
     (WFTY: WfTy Env5 Sch5),
     WfEnv (Env_Var Env5 x Sch5)
 | WfEnvObjSch : forall (Env5:Env) (A5:A) (Sch5:Sch)
     (WF: WfEnv Env5)
     (FR: FrA A5 Env5)
     (WFTY: WfTy (Env_A Env5 A5) Sch5),
     WfEnv (Env_Obj Env5 (Obj_Sch A5 Sch5)).

(* defns EnvironmentInstantiation *)
Inductive AInst : DEnv -> DSub -> A -> DA -> DSub -> Prop :=    (* defn AInst *)
 | AInstNil : forall (DEnv5:DEnv) (DSub5:DSub),
      True  ->
     AInst DEnv5 DSub5  nil   nil   nil 
 | AInstCons : forall (DEnvin:DEnv) (DSubin:DSub) (A5:A) (exA:exvar) (DA1 DA2:DA) (DSub_5:DSub) (DTy5:DTy)
     (WFDTY: WfDTy  ( DEnv_DA  DEnvin    (  DA2  ++  DA1  )   )  (DS_Mono DTy5)),
     AInst DEnvin DSubin A5 DA1 DSub_5 ->
     AInst DEnvin DSubin  ( cons  exA   A5  )    (  DA2  ++  DA1  )    ( (  exA ,  DTy5  ) ::  DSub_5  ) 
with EInst : DEnv -> DSub -> Env -> DEnv -> DSub -> Prop :=    (* defn EInst *)
 | EInstNil : forall (DEnv5:DEnv) (DSub5:DSub),
      True  ->
     EInst DEnv5 DSub5 Env_Empty DEnv_Empty  nil 
 | EInstA : forall (DEnvin:DEnv) (DSubin:DSub) (Env5:Env) (A5:A) (DEnv_5:DEnv) (DA5:DA) (DSub1 DSub2:DSub)
     (INST: EInst DEnvin DSubin Env5 DEnv_5 DSub1)
     (INSTA: AInst  (DEnv_app  DEnvin   DEnv_5 )   ( DSub1  ++  DSubin )  A5 DA5 DSub2),
     EInst DEnvin DSubin (Env_A Env5 A5)  ( DEnv_DA  DEnv_5   DA5  )   ( DSub2  ++  DSub1 ) 
 | EInstSch : forall (DEnvin:DEnv) (DSubin:DSub) (Env5:Env) (x:termvar) (Sch5:Sch) (DEnv_5:DEnv) (DSch5:DSch) (DSub_5:DSub)
     (INST: EInst DEnvin DSubin Env5 DEnv_5 DSub_5)
     (EMB:  (   ( DSub_app  Sch5     ( DSub_5  ++  DSubin )    )   = emb_Sch  DSch5  ) ),
     EInst DEnvin DSubin (Env_Var Env5 x Sch5) (DEnv_DVar DEnv_5 x DSch5) DSub_5
 | EInstObjSch : forall (DEnvin:DEnv) (DSubin:DSub) (Env5:Env) (A5:A) (Sch5:Sch) (DEnv_5:DEnv) (DA5:DA) (DSch5:DSch) (DSub_5 DSub':DSub)
     (INST: EInst DEnvin DSubin Env5 DEnv_5 DSub_5)
     (INSTA: AInst   (DEnv_app  DEnvin   DEnv_5 )     ( DSub_5  ++  DSubin )   A5 DA5 DSub')
     (EMB:  (   ( DSub_app  Sch5     (   ( DSub'  ++  DSub_5 )    ++  DSubin )    )   = emb_Sch  DSch5  ) ),
     EInst DEnvin DSubin (Env_Obj Env5 (Obj_Sch A5 Sch5)) (DEnv_DObj DEnv_5 (DObj_DSch DA5 DSch5)) DSub_5.


(** infrastructure *)
#[export] Hint Constructors DFrA TmMon TmDGen WfDTy WfDEnv SubSump FrA Inf Gen Inst U Us Uss WfTy WfEnv AInst EInst lc_DTy lc_Ty lc_DSch lc_Sch lc_DObj lc_Obj lc_e lc_DEnv lc_Env : core.


